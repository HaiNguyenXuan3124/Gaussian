# -*- coding: utf-8 -*-
"""Untitled16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_iuGglCqqFK3yJvg5DeBvFRfQu5m89KR
"""

import pandas as pd
df = pd.read_csv('/content/Vietnam.csv')
df

df.isna().sum()

# Chuyển cột thời gian về datetime và sắp xếp tăng dần
df['dt'] = pd.to_datetime(df['dt'])
df = df.sort_values('dt')

# Kiểm tra số lượng giá trị thiếu trước khi nội suy
missing_before = df['AverageTemperature'].isna().sum()

# Thực hiện nội suy tuyến tính trên cột nhiệt độ
df['AverageTemperature'] = df['AverageTemperature'].interpolate(method='linear')

# Kiểm tra lại số lượng giá trị thiếu sau khi nội suy
missing_after = df['AverageTemperature'].isna().sum()

missing_before, missing_after

import numpy as np

# Lấy giá trị nhiệt độ dạng numpy
temps = df['AverageTemperature'].values

# Tạo window với độ dài 24
def create_windows(series, window_size):
    X, y = [], []
    for i in range(len(series) - window_size):
        X.append(series[i:i+window_size])
        y.append(series[i+window_size])
    return np.array(X), np.array(y)

window_size = 24
X, y = create_windows(temps, window_size)

X.shape, y.shape

import torch
import torch.nn as nn
import torch.optim as optim

# Định nghĩa Simple Transformer Encoder
class SimpleTransformerEncoder(nn.Module):
    def __init__(self, input_dim, d_model, nhead, num_layers):
        super().__init__()
        self.embedding = nn.Linear(input_dim, d_model)
        encoder_layer = nn.TransformerEncoderLayer(d_model=d_model, nhead=nhead)
        self.transformer_encoder = nn.TransformerEncoder(encoder_layer, num_layers=num_layers)
        self.fc_out = nn.Linear(d_model, 1)

    def forward(self, x):
        # x: (batch, seq_len)
        x = x.unsqueeze(-1)  # (batch, seq_len, 1)
        x = self.embedding(x)  # (batch, seq_len, d_model)
        x = x.permute(1, 0, 2)  # (seq_len, batch, d_model)
        encoded = self.transformer_encoder(x)
        embedding = encoded[-1]  # embedding của phần tử cuối chuỗi
        output = self.fc_out(embedding)
        return output, embedding

# Chuyển dữ liệu sang tensor
X_tensor = torch.tensor(X, dtype=torch.float32)
y_tensor = torch.tensor(y, dtype=torch.float32)

# Khởi tạo mô hình
model = SimpleTransformerEncoder(input_dim=1, d_model=32, nhead=4, num_layers=2)
optimizer = optim.Adam(model.parameters(), lr=0.001)
criterion = nn.MSELoss()

# Huấn luyện mô hình nhanh (minh họa)
for epoch in range(10):
    optimizer.zero_grad()
    out, embedding = model(X_tensor)
    loss = criterion(out.squeeze(), y_tensor)
    loss.backward()
    optimizer.step()
    print('Epoch:', epoch, 'Loss:', loss.item())

# Lấy embedding toàn bộ mẫu để phân cụm
with torch.no_grad():
    _, embeddings = model(X_tensor)
    embeddings = embeddings.numpy()

from sklearn.mixture import GaussianMixture

# Phân cụm GMM trên embedding
gmm = GaussianMixture(n_components=3, random_state=0)
regimes = gmm.fit_predict(embeddings)

# Thêm chế độ vào DataFrame gốc
df_result = df.copy()
# Tạo một cột 'regime' khớp số dòng với df gốc (phải bù NAs cho phần đầu)
regime_col = [None]*window_size + list(regimes)
df_result['regime'] = regime_col

# Xuất ra file kết quả
df_result.to_csv('/content/Vietnam_with_regime.csv', index=False)

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, shuffle=False)

from sklearn.preprocessing import StandardScaler

scaler_X = StandardScaler()
scaler_y = StandardScaler()

X_train_scaled = scaler_X.fit_transform(X_train)
X_test_scaled = scaler_X.transform(X_test)
y_train_scaled = scaler_y.fit_transform(y_train.reshape(-1,1)).flatten()
y_test_scaled = scaler_y.transform(y_test.reshape(-1,1)).flatten()

import torch
import torch.nn as nn
import torch.optim as optim

X_train_tensor = torch.tensor(X_train_scaled, dtype=torch.float32)
y_train_tensor = torch.tensor(y_train_scaled, dtype=torch.float32)
X_test_tensor = torch.tensor(X_test_scaled, dtype=torch.float32)
y_test_tensor = torch.tensor(y_test_scaled, dtype=torch.float32)

model = SimpleTransformerEncoder(input_dim=1, d_model=32, nhead=4, num_layers=2)
optimizer = optim.Adam(model.parameters(), lr=0.001)
criterion = nn.MSELoss()

EPOCHS = 50
for epoch in range(EPOCHS):
    model.train()
    optimizer.zero_grad()
    out, _ = model(X_train_tensor)
    loss = criterion(out.squeeze(), y_train_tensor)
    loss.backward()
    optimizer.step()
    if (epoch+1) % 10 == 0 or epoch == 0:
        print(f'Epoch {epoch+1}/{EPOCHS} - Train Loss: {loss.item():.4f}')

model.eval()
with torch.no_grad():
    y_pred_test_scaled, _ = model(X_test_tensor)
    y_pred_test_scaled = y_pred_test_scaled.squeeze().numpy()

# Đảo ngược chuẩn hóa
y_pred_test = scaler_y.inverse_transform(y_pred_test_scaled.reshape(-1, 1)).flatten()
y_test_orig = scaler_y.inverse_transform(y_test_scaled.reshape(-1, 1)).flatten()

# Tính chỉ số đánh giá
from sklearn.metrics import mean_absolute_error, mean_squared_error
import numpy as np

mae = mean_absolute_error(y_test_orig, y_pred_test)
rmse = np.sqrt(mean_squared_error(y_test_orig, y_pred_test))
print(f'Test MAE: {mae:.4f}, Test RMSE: {rmse:.4f}')

# Lấy chỉ mục thời gian cho tập kiểm thử
# df_result đã được tạo trước đó và chứa cột 'dt'
test_dates = df_result['dt'][window_size + len(X_train):].reset_index(drop=True)

plt.figure(figsize=(14,5))
plt.plot(test_dates, y_test_orig, label='True')
plt.plot(test_dates, y_pred_test, label='Predicted')
plt.title('Dự báo nhiệt độ trung bình theo thời gian')
plt.xlabel('Thời gian')
plt.ylabel('Nhiệt độ trung bình')
plt.legend()
plt.tight_layout()
plt.show()